package frc.robot;

import static edu.wpi.first.wpilibj.util.ErrorMessages.requireNonNullParam;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.Filesystem;
import edu.wpi.first.wpilibj.SpeedControllerGroup;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.controller.PIDController;
import edu.wpi.first.wpilibj.controller.RamseteController;
import edu.wpi.first.wpilibj.controller.SimpleMotorFeedforward;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.kinematics.ChassisSpeeds;
import edu.wpi.first.wpilibj.kinematics.DifferentialDriveKinematics;
import edu.wpi.first.wpilibj.kinematics.DifferentialDriveOdometry;
import edu.wpi.first.wpilibj.kinematics.DifferentialDriveWheelSpeeds;
import edu.wpi.first.wpilibj.trajectory.Trajectory;
import edu.wpi.first.wpilibj.trajectory.TrajectoryUtil;

import java.io.IOException;
import java.nio.file.Path;

import com.kauailabs.navx.frc.AHRS;

@SuppressWarnings("PMD.TooManyFields")
public class RobotPathController {
  private final Timer m_timer = new Timer();
 //private final boolean m_usePID;
  private final Trajectory m_trajectory;
 // private final Supplier<Pose2d> m_pose;
  private AHRS m_gyro;//
  private DifferentialDriveOdometry m_odometry;//
  private CTREEncoder m_leftEncoder;//
  private CTREEncoder m_rightEncoder;//
  private DifferentialDrive m_mainDrive;//
  private SpeedControllerGroup m_left;//
  private SpeedControllerGroup m_right;//
  private final RamseteController m_follower;
  private final SimpleMotorFeedforward m_feedforward;
  private final DifferentialDriveKinematics m_kinematics;
 // private final Supplier<DifferentialDriveWheelSpeeds> m_speeds;
  private final PIDController m_leftController;
  private final PIDController m_rightController;
 // private final BiConsumer<Double, Double> m_output;
  private DifferentialDriveWheelSpeeds m_prevSpeeds;
  private double m_prevTime;

  /**
   * Constructs a new RamseteCommand that, when executed, will follow the provided trajectory. PID
   * control and feedforward are handled internally, and outputs are scaled -12 to 12 representing
   * units of volts.
   *
   * <p>Note: The controller will *not* set the outputVolts to zero upon completion of the path -
   * this is left to the user, since it is not appropriate for paths with nonstationary endstates.
   *
   * @param mainDrive This is the DifferentialDrive of the robot
   * @param left The left SpeedControllerGroup
   * @param right The right SpeedControllerGroup
   * @param pathName The name of the path generated by PathWeaver
   * @param gyro An AHRS (NavX) gyroscope used for odometry
   * @param controller The RAMSETE controller used to follow the trajectory.
   * @param feedforward The feedforward to use for the drive.
   * @param kinematics The kinematics for the robot drivetrain.
   * @param leftController The PIDController for the left side of the robot drive.
   * @param rightController The PIDController for the right side of the robot drive.
   * @param leftEncoder The CTREEncoder for the left side of the robot
   * @param rightEncoder The CTREEncoder for the right side of the robot
   */
  @SuppressWarnings("PMD.ExcessiveParameterList")
  public RobotPathController(
      DifferentialDrive mainDrive,
      SpeedControllerGroup left,
      SpeedControllerGroup right,
      String pathName,
      AHRS gyro,
      RamseteController controller,
      SimpleMotorFeedforward feedforward,
      DifferentialDriveKinematics kinematics,
      PIDController leftController,
      PIDController rightController,
      CTREEncoder leftEncoder,
      CTREEncoder rightEncoder) {
          
    String trajectoryJSON = "paths/output/" + pathName;
    Trajectory trajectory = new Trajectory();
    try {
      Path trajectoryPath = Filesystem.getDeployDirectory().toPath().resolve(trajectoryJSON);
      trajectory = TrajectoryUtil.fromPathweaverJson(trajectoryPath);
    } catch (IOException ex) {
      DriverStation.reportError("Unable to open trajectory: " + trajectoryJSON, ex.getStackTrace());
    }
    m_trajectory = trajectory;
    
    m_gyro = requireNonNullParam(gyro, "gyro", "RamseteCommand");
    m_follower = requireNonNullParam(controller, "controller", "RamseteCommand");
    m_feedforward = feedforward;
    m_kinematics = requireNonNullParam(kinematics, "kinematics", "RamseteCommand");
    m_leftController = requireNonNullParam(leftController, "leftController", "RamseteCommand");
    m_rightController = requireNonNullParam(rightController, "rightController", "RamseteCommand");
    m_leftEncoder = leftEncoder;
    m_rightEncoder = rightEncoder;
    m_mainDrive = mainDrive;
    m_left = left;
    m_right = right;

    m_odometry = new DifferentialDriveOdometry(m_gyro.getRotation2d());
  }

  public void initialize() {
    m_prevTime = -1;
    var initialState = m_trajectory.sample(0);
    m_prevSpeeds = m_kinematics.toWheelSpeeds(new ChassisSpeeds(initialState.velocityMetersPerSecond, 0, initialState.curvatureRadPerMeter * initialState.velocityMetersPerSecond));
    m_timer.reset();
    m_timer.start();

    m_leftController.reset();
    m_rightController.reset();
  }

  public void execute() {
    if(isFinished()) return;

    m_odometry.update(m_gyro.getRotation2d(), m_leftEncoder.getDistance(), m_rightEncoder.getDistance());

    double curTime = m_timer.get();
    double dt = curTime - m_prevTime;

    if (m_prevTime < 0) {
      m_left.setVoltage(0.0);
      m_right.setVoltage(0.0);
      m_mainDrive.tankDrive(0.0, 0.0);
      m_prevTime = curTime;
      return;
    }

    var targetWheelSpeeds = m_kinematics.toWheelSpeeds(m_follower.calculate(m_odometry.getPoseMeters(), m_trajectory.sample(curTime)));

    var leftSpeedSetpoint = targetWheelSpeeds.leftMetersPerSecond;
    var rightSpeedSetpoint = targetWheelSpeeds.rightMetersPerSecond;

    double leftOutput;
    double rightOutput;

    double leftFeedforward = m_feedforward.calculate(leftSpeedSetpoint, (leftSpeedSetpoint - m_prevSpeeds.leftMetersPerSecond) / dt);
    double rightFeedforward = m_feedforward.calculate(rightSpeedSetpoint, (rightSpeedSetpoint - m_prevSpeeds.rightMetersPerSecond) / dt);

    leftOutput = leftFeedforward + m_leftController.calculate(m_leftEncoder.getRate(), leftSpeedSetpoint);
    rightOutput = rightFeedforward + m_rightController.calculate(m_rightEncoder.getRate(), rightSpeedSetpoint);


    m_left.setVoltage(leftOutput);
    m_right.setVoltage(-rightOutput);
    m_mainDrive.feed();

    m_prevSpeeds = targetWheelSpeeds;
    m_prevTime = curTime;

  }

  public void end(boolean interrupted) {
    m_timer.stop();
  }

  public boolean isFinished() {
    return m_timer.hasElapsed(m_trajectory.getTotalTimeSeconds());
  }
}
